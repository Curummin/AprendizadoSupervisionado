# %% [markdown]
# #   Modelo de Regressão Linear 

# %%
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.pipeline import Pipeline
from sklearn.linear_model import LinearRegression

# %% [markdown]
# ## Coleta de dados

# %%
# Adicionar codificação para reconhecimento do ç e acentos
queimadas = pd.read_csv('amazon.csv', encoding='iso-8859-1')
print(queimadas.head())

# %% [markdown]
# # Pré-processamento

# %%
# Removendo dados faltantes
print("Dados faltantes antes:", queimadas.isnull().sum().sum())
queimadas = queimadas.dropna()

# --- ETAPA SOLICITADA: REMOVER A COLUNA 'DATE' ---
# A coluna 'date' não é útil para a regressão linear simples sem tratamento prévio, 
# pois contém datas completas que gerariam muitas categorias ou erros.
if 'date' in queimadas.columns:
    queimadas = queimadas.drop(['date'], axis=1)

# %% [markdown]
# # Construindo Modelo LR composta

# %% [markdown]
# Divisão dos dados em treinamento (70%) e teste (30%)

# %%
# Definindo o alvo (Target)
y_val = queimadas['number']

# Selecionando variáveis de entrada (features)
# Removemos a coluna alvo 'number'. A coluna 'date' já foi removida acima.
X_val = queimadas.drop(['number'], axis=1)

# Transformar variáveis categóricas (como 'state' e 'month') em numéricas (One-Hot Encoding)
X_val = pd.get_dummies(X_val, drop_first=True)

# Dividindo os dados: 70% treino, 30% teste
x_train, x_test, y_train, y_test = train_test_split(
    X_val, y_val, test_size=0.3, random_state=42
)

print("Tamanho do treino:", x_train.shape)
print("Tamanho do teste:", x_test.shape)

# %% [markdown]
# ## Treinamento e Avaliação do Modelo

# %%
# Criando um Pipeline:
# 1. StandardScaler: Padroniza os dados (média 0, desvio padrão 1), importante para regressão linear.
# 2. LinearRegression: O algoritmo do modelo.
modelo_pipeline = Pipeline([
    ('scaler', StandardScaler()),
    ('regressor', LinearRegression())
])

# Treinando o modelo com os dados de treino
modelo_pipeline.fit(x_train, y_train)

# Fazendo predições nos dados de teste
y_pred = modelo_pipeline.predict(x_test)

# Avaliando o modelo (R² Score)
score = modelo_pipeline.score(x_test, y_test)
print(f"Coeficiente de Determinação (R^2): {score:.4f}")

# Plotando Gráfico de Dispersão: Real vs Predito
plt.figure(figsize=(10, 6))
plt.scatter(y_test, y_pred, alpha=0.5)
plt.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], 'r--', lw=2) # Linha ideal
plt.xlabel('Valores Reais')
plt.ylabel('Valores Preditos')
plt.title('Regressão Linear: Real vs Predito')
plt.show()
